const { stripIndents } = require("common-tags");
const { verify, list, promptMessage } = require("./functions");
const { MessageEmbed } = require("discord.js");
const { Aki } = require("aki-api");
const chooseArr = ["ðŸ—»", "ðŸ“°", "âœ‚"];

class tictactoe {
  constructor(openonent, message) {
    if (!message) return new Error("Please provide the message object");
    this.openonent = openonent;
    this.message = message;
  }
  async init(options) {
    this.provide_member = options.PROVIDE_MEMBER;
    this.accept_challenge = options.ACCEPT_CHALLENGE
    this.doesnt_play = options.DOESNT_PLAY
    this.wich_side = options.WICH_SIDE
    this.game_over = options.GAME_OVER
    this.end = options.END
    this.inactivity = options.INACTIVITY
    this.winner = options.WINNER
    this.draw = options.DRAW
    if(!this.provide_member) this.provide_member = "Please provide a member"
    if(!this.doesnt_play) this.doesnt_play = "**Looks like {user} doesnt wanna play!**"
    if(!this.accept_challenge) this.accept_challenge = "**{user} Do you accept this challenge?**"
    if(!this.wich_side) this.wich_side = "**{user}, Which Side Do You Pick? Type \`End\` To Forfeit!**"
    if(!this.game_over) this.game_over = "**Times up** Game is over"
    if(!this.end) this.end = "end"
    if(!this.inactivity) this.inactivity = "**Game Ended Due To Inactivity!**"
    if(!this.winner) this.winner = "**Congrats {winner}"
    if(!this.draw) this.draw = "**Its a Draw**"
    if (!this.openonent)
      return this.message.channel.send(this.provide_member);
    try {
      await this.message.channel.send(this.accept_challenge.replace("{user}", this.openonent)
      .replace("%USER%", this.openonent));
      const verification = await verify(this.message.channel, this.openonent);
      if (!verification) {
        return this.message.channel.send(this.doesnt_play.replace("{user}", this.openonent)
        .replace("%USER%", this.openonent));
      }
      const sides = ["1", "2", "3", "4", "5", "6", "7", "8", "9"];
      const taken = [];
      let userTurn = true;
      let winner = null;
      let lastTurnTimeout = false;
      while (!winner && taken.length < 9) {
        const user = userTurn ? this.message.author : this.openonent;
        const sign = userTurn ? "X" : "O";
        await this.message.channel.send(stripIndents`
                ${this.wich_side.replace("{user}", user).replace("%user%", user)}
                \`\`\`
                ${sides[0]} | ${sides[1]} | ${sides[2]}
                â€”â€”â€”â€”â€”â€”â€”â€”â€”
                ${sides[3]} | ${sides[4]} | ${sides[5]}
                â€”â€”â€”â€”â€”â€”â€”â€”â€”
                ${sides[6]} | ${sides[7]} | ${sides[8]}
                \`\`\`
            `);
        const filter = (res) => {
          if (res.author.id !== user.id) return false;
          const choice = res.content;
          if (choice.toLowerCase() === "end") return true;
          return sides.includes(choice) && !taken.includes(choice);
        };
        const turn = await this.message.channel.awaitMessages(filter, {
          max: 1,
          time: 30000,
        });
        if (!turn.size) {
          await this.message.channel.send(this.game_over);
          if (lastTurnTimeout) {
            winner = "time";
            break;
          } else {
            userTurn = !userTurn;
            lastTurnTimeout = true;
            continue;
          }
        }
        const choice = turn.first().content;
        if (choice.toLowerCase() === this.end) {
          winner = userTurn ? this.openonent : this.message.author;
          break;
        }
        sides[Number.parseInt(choice, 10) - 1] = sign;
        taken.push(choice);
        if (verifyWin(sides))
          winner = userTurn ? this.message.author : this.openonent;
        if (lastTurnTimeout) lastTurnTimeout = false;
        userTurn = !userTurn;
      }
      if (winner === "time")
        return this.message.channel.send(this.inactivity);
      return this.message.channel.send(
        winner ? this.winner.replace("{winner}", winner).replace("%winner%", winner) : this.draw
      );
    } catch (err) {
      throw err;
    }

    function verifyWin(sides) {
      return (
        (sides[0] === sides[1] && sides[0] === sides[2]) ||
        (sides[0] === sides[3] && sides[0] === sides[6]) ||
        (sides[3] === sides[4] && sides[3] === sides[5]) ||
        (sides[1] === sides[4] && sides[1] === sides[7]) ||
        (sides[6] === sides[7] && sides[6] === sides[8]) ||
        (sides[2] === sides[5] && sides[2] === sides[8]) ||
        (sides[0] === sides[4] && sides[0] === sides[8]) ||
        (sides[2] === sides[4] && sides[2] === sides[6])
      );
    }
  }
}

class akinator {
  constructor(message, args) {
    if (!message) return new Error("Please provide the message object!");
    if (!args) return new Error("Please give the args object");
    this.args = args;
    this.message = message;
  }
  async init() {
    const regions = ["person", "object","animal"];
    if (!this.args[0])
      return this.message.channel.send(
        `**What category u want to use? Either\`${list(
          regions,
          "or"
        )}\`!**`
      );
    let stringAki = this.args[0].toLowerCase();
    let region;
    if (stringAki === "person".toLocaleLowerCase()) region = "en";
    if (stringAki === "object".toLocaleLowerCase()) region = "en_objects";
    if (stringAki === "animal".toLocaleLowerCase()) region = "en_animals";
    if (!regions.includes(stringAki))
      return this.message.channel.send(
        `**What Region Do You Want To Use? Either \`${list(regions, "or")}\`!**`
      );
    try {
      const aki = new Aki(region);
      let ans = null;
      let win = false;
      let timesGuessed = 0;
      let guessResetNum = 0;
      let wentBack = false;
      let forceGuess = false;
      const guessBlacklist = [];
      while (timesGuessed < 3) {
        if (guessResetNum > 0) guessResetNum--;
        if (ans === null) {
          await aki.start();
        } else if (wentBack) {
          wentBack = false;
        } else {
          try {
            await aki.step(ans);
          } catch {
            await aki.step(ans);
          }
        }
        if (!aki.answers || aki.currentStep >= 79) forceGuess = true;
        const answers = aki.answers.map((answer) => answer.toLowerCase());
        answers.push("end");
        if (aki.currentStep > 0) answers.push("back");
        const embed = new MessageEmbed()
          .setAuthor(
            this.message.author.username,
            this.message.author.displayAvatarURL()
          )
          .setColor("GREEN")
          .setDescription(
            `**Q${aki.currentStep + 1} - ${aki.question}**\n${aki.answers.join(
              " | "
            )}${aki.currentStep > 0 ? ` | Back` : ""} | End`
          )
          .setFooter(
            `Yes/No To Confirm | Progress - ${Math.round(
              Number.parseInt(aki.progress, 10)
            )}%`
          );
        await this.message.channel.send(embed);
        const filter = (res) =>
          res.author.id === this.message.author.id &&
          answers.includes(res.content.toLowerCase());
        const messages = await this.message.channel.awaitMessages(filter, {
          max: 1,
          time: 30000,
        });
        if (!messages.size) {
          await message.channel.send("**Time Up!**");
          win = "time";
          break;
        }
        const choice = messages.first().content.toLowerCase();
        if (choice.toLowerCase() === "end".toLocaleLowerCase()) {
          forceGuess = true;
        } else if (choice.toLowerCase() === "back".toLocaleLowerCase()) {
          if (guessResetNum > 0) guessResetNum++;
          wentBack = true;
          await aki.back();
          continue;
        } else {
          ans = answers.indexOf(choice);
        }
        if ((aki.progress >= 90 && !guessResetNum) || forceGuess) {
          timesGuessed++;
          guessResetNum += 10;
          await aki.win();
          const guess = aki.answers.filter(
            (g) => !guessBlacklist.includes(g.id)
          )[0];
          if (!guess) {
            await this.message.channel.send("**I Can't Think of Anyone!**");
            win = true;
            break;
          }
          guessBlacklist.push(guess.id);
          const embed = new MessageEmbed()
            .setAuthor(
              this.message.author.username,
              this.message.author.displayAvatarURL()
            )
            .setColor("RED")
            .setTitle(`I'm ${Math.round(guess.proba * 100)}% Sure It's...`)
            .setDescription(
              `**${guess.name}${
                guess.description ? `\nProfession - ${guess.description}` : ""
              }\nRanking - ${guess.ranking}\nType Yes/No To Confirm!**`
            )
            .setImage(guess.absolute_picture_path || null)
            .setFooter(
              forceGuess ? "Final Guess" : `Guesses - ${timesGuessed}`
            );
          await this.message.channel.send(embed);
          const verification = await verify(
            this.message.channel,
            this.message.author
          );
          if (verification === 0) {
            win = "time";
            break;
          } else if (verification) {
            win = false;
            break;
          } else {
            const exmessage =
              timesGuessed >= 3 || forceGuess
                ? "I Give Up!"
                : "I Can Keep Going!";
            await this.message.channel.send(
              `**Hmm... Is That so? ${exmessage}**`
            );
            if (timesGuessed >= 3 || forceGuess) {
              win = true;
              break;
            }
          }
        }
      }
      if (win === "time")
        return this.message.channel.send(
          "**I Guess Your Silence Means I Have Won!**"
        );
      if (win)
        return this.message.channel.send("**You Have Defeated Me This Time!**");
      return this.message.channel.send(
        "**Guessed Right One More Time! I Love Playing With You!**"
      );
    } catch (err) {
      return this.message.channel.send(`**Server Down, Try again later!**`);
    }
  }
}

class rps {
  constructor(message) {
    if (!message) throw new Error("Provide the message object please!");
    this.message = message;
  }
  async init(options) {
    this.select = options.SELECT_REACTION
    this.won = options.WON
    this.tie = options.TIE
    this.lost = options.LOST
    this.missing = options.MISSING_PERMISSIONS
    if(!this.missing) this.missing = "**Missing Permissions - {permission}!**"
    if(!this.select) this.select = "**Play A Game of RPS Against The Bot!\nSelect Reactions To Play!**"
    if(!this.lost) this.lost = "You lost!"
    if(!this.won) this.won = "You won!"
    if(!this.tie) this.tie = "Its a tie!"
    try {
      const embed = new MessageEmbed()
        .setColor("GREEN")
        .setAuthor(
          this.message.member.displayName,
          this.message.author.displayAvatarURL()
        )
        .setFooter(this.message.guild.me.displayName)
        .setDescription(this.select)
        .setTimestamp();

      const m = await this.message.channel.send(embed);
      const reacted = await promptMessage(
        m,
        this.message.author,
        30,
        chooseArr
      );

      const botChoice = chooseArr[Math.floor(Math.random() * chooseArr.length)];

      const result = await getResult(reacted, botChoice);
      await m.reactions.removeAll();

      embed
        .setDescription("")
        .addField(`**${result}**`, `${reacted} vs ${botChoice}`);

      m.edit(embed);
    } catch {
      return thismessage.channel.send(this.missing.replace("{permission}", "MANAGE_MESSAGES").replace("%permission%", "MANAGE_MESSAGES"));
    }
    function getResult(me, botChosen) {
      if (
        (me === "ðŸ—»" && botChosen === "âœ‚") ||
        (me === "ðŸ“°" && botChosen === "ðŸ—»") ||
        (me === "âœ‚" && botChosen === "ðŸ“°")
      ) {
        return this.won;
      } else if (me === botChosen) {
        return this.tie;
      } else {
        return this.lost;
      }
    }
  }
}
module.exports = {
  tictactoe,
  akinator,
  rps,
};
